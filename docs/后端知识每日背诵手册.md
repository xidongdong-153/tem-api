# 🧠 后端知识每日背诵手册

> 💡 **前端开发者专用** | 每天10分钟，建立后端思维

<p align="center">
  <img src="https://img.shields.io/badge/每日时间-10分钟-blue?style=for-the-badge" alt="每日10分钟" />
  <img src="https://img.shields.io/badge/记忆方式-强化背诵-orange?style=for-the-badge" alt="强化背诵" />
</p>

---

## 📚 使用说明

**🎯 背诵方法：**
1. **早上背诵**：起床后花5分钟背诵当日内容
2. **晚上复习**：睡前花5分钟复习+前一天内容
3. **周末总结**：每周末复习本周所有内容
4. **对比联想**：用前端概念类比理解后端概念

**📋 背诵技巧：**
- 🗣️ **大声朗读**：说出来比默读记得更牢
- 📝 **手写笔记**：动手写比看更有效果
- 🎭 **角色扮演**：把自己当成后端架构师
- 🤔 **举一反三**：想想这个概念在你项目中的应用

**📈 学习进度规划（已优化整理）：**
- **第1周（1-7天）**：核心思维转换，建立后端基础认知
- **第2周（8-20天）**：深入核心组件，掌握NestJS技术细节
- **第3周（21-34天）**：企业级特性+分布式系统，学习高级概念
- **第4周（35-41天）**：实战开发套路，形成完整知识体系
- **第5周（42-48天）**：Node.js底层知识（可选扩展）

**📝 优化说明：**
- ✅ **合并重复内容**：将分散的网络通信、缓存、装饰器知识整合
- ✅ **精简章节**：从51天压缩到48天，去除冗余重复
- ✅ **知识聚焦**：每个主题集中在一个章节，避免知识碎片化
- ✅ **逻辑优化**：重新调整学习顺序，循序渐进更合理

---

## 📅 第1周：核心思维转换

### 📖 第1天：后端思维 vs 前端思维

**🔄 核心思维差异（必背）：**
```
前端管"界面" → 后端管"数据"
前端管"展示" → 后端管"逻辑"
前端管"用户体验" → 后端管"数据安全"
前端管"响应式" → 后端管"无状态"
```

**🏠 生活化类比（必记）：**
- **前端** = 餐厅服务员（接待客人，展示菜单）
- **后端** = 餐厅后厨（处理订单，制作菜品）
- **数据库** = 食材仓库（存储原料）
- **API** = 传菜窗口（前后端沟通渠道）

**📝 关键概念：**
- **无状态服务**：每个请求都是独立的，不记住上次的状态
- **数据持久化**：数据要永久保存在数据库中，不能丢失

### 📖 第2天：NestJS架构思维

**🏗️ 核心架构（必背）：**
```
Controller（控制器）= Vue的事件处理
Service（服务）= Vue的methods逻辑
Entity（实体）= Vue的data结构
Module（模块）= Vue的组件
```

**🔄 请求生命周期（必记）：**
```
1. 客户端发请求 → Controller接收
2. Controller调用 → Service处理业务
3. Service操作 → Database存取数据
4. Database返回 → Service处理结果
5. Service返回 → Controller响应客户端
```

**📝 关键概念：**
- **分层架构**：Controller→Service→Repository→Database，各司其职
- **单一职责**：每个层只做自己该做的事

### 📖 第3天：依赖注入（DI）

**💉 依赖注入类比（必背）：**
```
// 前端手动创建
const userService = new UserService()

// 后端自动注入
constructor(private userService: UserService) {}
```

**🎯 依赖注入好处（必记）：**
- **自动创建**：框架帮你创建和管理对象
- **单例模式**：同一个服务在整个应用中只有一个实例
- **测试友好**：可以轻松替换成测试用的假对象

**📝 关键概念：**
- **IoC容器**：像个智能工厂，需要什么就给你创建什么
- **Provider**：可以被注入的服务

### 📖 第4天：装饰器（Decorator）基础

**🎭 装饰器本质（必背）：**
```typescript
// 装饰器就是一个函数，用来修改类、方法、属性等
function MyDecorator(target: any) {
  // 给目标对象添加或修改功能
  return target
}

// 使用装饰器等价于
class MyClass {}
MyClass = MyDecorator(MyClass)
```

**🔧 常用NestJS装饰器（必记）：**
- `@Controller()` = 定义路由控制器
- `@Get()/@Post()` = 定义HTTP方法
- `@Injectable()` = 标记可注入服务
- `@Module()` = 定义模块

**🎯 装饰器的四种类型与重要参数（必背）：**

**1. 类装饰器：**
```typescript
function ClassDecorator(target: Function) {
  // target: 被装饰的类的构造函数
}
```

**2. 方法装饰器（最常用）：**
```typescript
function MethodDecorator(
  target: any,                    // 类的原型对象
  propertyKey: string,            // 方法名称
  descriptor: PropertyDescriptor  // 方法描述符（可修改方法行为）
) {}
```

**3. 属性装饰器：**
```typescript
function PropertyDecorator(
  target: any,          // 类的原型对象
  propertyKey: string   // 属性名称
) {}
```

**4. 参数装饰器：**
```typescript
function ParameterDecorator(
  target: any,          // 类的原型对象
  propertyKey: string,  // 方法名称
  parameterIndex: number // 参数索引位置
) {}
```

**📝 关键要点：**
- **target**：始终是被装饰的对象
- **propertyKey**：方法/属性的名称字符串
- **descriptor**：方法装饰器独有，用于修改方法行为
- **parameterIndex**：参数装饰器独有，标识参数位置

### 📖 第5天：模块化思维

**🧩 模块化对比（必背）：**
```
// Vue组件
export default {
  components: { UserList },  // 子组件
  props: ['users'],          // 输入
  methods: { createUser }    // 方法
}

// NestJS模块
@Module({
  imports: [DatabaseModule],    // 依赖模块
  controllers: [UserController], // 控制器
  providers: [UserService],     // 服务
  exports: [UserService]        // 对外导出
})
```

**🎯 模块设计原则（必记）：**
- **高内聚**：模块内部功能紧密相关
- **低耦合**：模块之间依赖关系简单
- **单一职责**：一个模块负责一个业务领域

### 📖 第6天：网络通信基础

**🌐 网络协议分层（必背）：**
```
应用层：HTTP、HTTPS、FTP、SMTP（我们写的API）
传输层：TCP、UDP（数据如何传输）
网络层：IP（数据路由寻址）
链路层：以太网（物理传输）
```

**📡 HTTP协议核心（必背）：**
```
HTTP请求流程：
客户端 → [请求] → 服务器 → [响应] → 客户端
       ↓                    ↓
   包含：方法+路径+头部+数据    包含：状态码+头部+数据

状态码分类：
2xx：成功（200 OK，201 Created，204 No Content）
4xx：客户端错误（400 参数错误，401 未认证，403 禁止访问，404 不存在）
5xx：服务器错误（500 内部错误，502 网关错误，503 服务不可用）
```

**⚡ TCP vs UDP对比（必记）：**
- **TCP（可靠传输）**：面向连接、保证可靠性、适合HTTP/数据库
- **UDP（快速传输）**：无连接、速度快、适合视频流/游戏

**🔗 RPC vs HTTP（必背）：**
- **RPC**：面向过程调用、性能更高、微服务内部通信
- **HTTP**：面向资源操作、通用标准、对外API接口

**📝 关键概念：**
- **RESTful API**：用HTTP方法表示操作（GET查询，POST创建，PUT更新，DELETE删除）
- **三次握手**：TCP建立连接的过程
- **keep-alive**：HTTP连接复用机制

### 📖 第7天：第一周总结

**🧠 核心思维转换总结（必背3遍）：**
1. **数据中心思维**：一切围绕数据的增删改查
2. **分层架构思维**：每一层各司其职，不越界
3. **服务化思维**：把功能拆分成独立的服务
4. **无状态思维**：每个请求都是独立的
5. **依赖注入思维**：让框架管理对象创建

---

## 📅 第2周：核心组件深入

### 📖 第8天：Controller（控制器）

**🎯 Controller职责（必背）：**
```
1. 接收HTTP请求
2. 验证请求参数
3. 调用Service处理业务
4. 返回HTTP响应
```

**🔧 Controller写法（必记）：**
```typescript
@Controller('users')  // 路由前缀
export class UsersController {
  @Get()              // GET /api/users
  @Post()             // POST /api/users
  @Get(':id')         // GET /api/users/123
  @Put(':id')         // PUT /api/users/123
  @Delete(':id')      // DELETE /api/users/123
}
```

**📝 关键概念：**
- **路由**：URL路径与处理函数的映射
- **RESTful设计**：用URL表示资源，用HTTP方法表示操作

### 📖 第9天：Service（服务层）

**⚙️ Service职责（必背）：**
```
1. 业务逻辑处理
2. 数据验证
3. 调用数据库操作
4. 事务管理
```

**🎭 Service vs Controller（必记）：**
- **Controller**：薄薄一层，只负责HTTP相关
- **Service**：厚厚一层，包含所有业务逻辑
- **原则**：Controller不写业务逻辑，Service不碰HTTP

**📝 关键概念：**
- **业务逻辑**：应用的核心规则和流程
- **事务**：要么全部成功，要么全部失败

### 📖 第10天：DTO（数据传输对象）

**📦 DTO作用（必背）：**
```
1. 定义API输入输出格式
2. 自动验证数据
3. 自动转换类型
4. 生成API文档
```

**✅ DTO验证装饰器（必记）：**
- `@IsString()` = 必须是字符串
- `@IsEmail()` = 必须是邮箱格式
- `@MinLength(6)` = 最小长度6位
- `@IsOptional()` = 可选字段

**📝 关键概念：**
- **数据契约**：前后端数据交换的约定
- **验证在服务端**：永远不信任客户端数据

### 📖 第11天：Entity（实体）

**🏛️ Entity作用（必背）：**
```
1. 定义数据库表结构
2. 对象关系映射（ORM）
3. 数据验证约束
4. 关系定义
```

**🔗 Entity装饰器（必记）：**
- `@Entity()` = 标记为数据库表
- `@PrimaryKey()` = 主键
- `@Property()` = 普通字段
- `@Unique()` = 唯一约束

**📝 关键概念：**
- **ORM**：用对象的方式操作数据库
- **ActiveRecord模式**：实体对象包含数据+操作方法

### 📖 第12天：Repository（仓储层）

**🏛️ Repository作用（必背）：**
```
1. 数据访问封装
2. 查询逻辑集中
3. 业务与数据分离
4. 统一数据操作接口
```

**🔄 Repository vs Service（必记）：**
- **Repository**：专注数据访问，只做CRUD
- **Service**：专注业务逻辑，调用Repository
- **原则**：Repository不写业务逻辑，Service不直接操作数据库

**🎯 Repository模式类比（必背）：**
```
// 前端状态管理
const userStore = useUserStore()  // 统一管理用户数据

// 后端Repository
const userRepository = new UserRepository()  // 统一管理用户数据访问
```

**📝 关键概念：**
- **数据访问层**：专门负责与数据库交互的层次
- **查询封装**：把复杂的数据库查询封装成简单的方法

### 📖 第13天：Guard（守卫）

**🛡️ Guard作用（必背）：**
```
1. 权限检查
2. 身份验证
3. 角色验证
4. 请求拦截
```

**🔐 Guard执行时机（必记）：**
```
请求 → Guard检查 → Controller执行
     ↓
   通过继续，不通过直接返回错误
```

**📝 关键概念：**
- **认证**：你是谁（Authentication）
- **授权**：你能做什么（Authorization）

### 📖 第14天：Interceptor（拦截器）

**🔄 Interceptor作用（必背）：**
```
1. 请求前处理
2. 响应后处理
3. 统一日志记录
4. 统一响应格式
```

**⏰ Interceptor执行顺序（必记）：**
```
请求 → 拦截器前置 → Controller → 拦截器后置 → 响应
```

**📝 关键概念：**
- **AOP**：面向切面编程，横切关注点
- **管道模式**：数据流经多个处理器

### 📖 第15天：装饰器深入与实践

**🎯 装饰器四种类型与参数（必背）：**

**1. 类装饰器：**
```typescript
function ClassDecorator(target: Function) {
  // target: 被装饰的类的构造函数
}
```

**2. 方法装饰器（最常用）：**
```typescript
function MethodDecorator(
  target: any,                    // 类的原型对象
  propertyKey: string,            // 方法名称
  descriptor: PropertyDescriptor  // 方法描述符（可修改方法行为）
) {}
```

**3. 属性装饰器：**
```typescript
function PropertyDecorator(
  target: any,          // 类的原型对象
  propertyKey: string   // 属性名称
) {}
```

**4. 参数装饰器：**
```typescript
function ParameterDecorator(
  target: any,          // 类的原型对象
  propertyKey: string,  // 方法名称
  parameterIndex: number // 参数索引位置
) {}
```

**🔧 实用装饰器案例（必记）：**

**1. 缓存装饰器：**
```typescript
export function Cacheable(ttl: number = 300) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value
    
    descriptor.value = async function (...args: any[]) {
      const cacheKey = `${propertyKey}:${JSON.stringify(args)}`
      
      let result = await this.cacheService.get(cacheKey)
      if (!result) {
        result = await originalMethod.apply(this, args)
        await this.cacheService.set(cacheKey, result, ttl)
      }
      
      return result
    }
  }
}
```

**2. 性能监控装饰器：**
```typescript
function Performance(threshold = 1000) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value
    
    descriptor.value = async function (...args: any[]) {
      const start = Date.now()
      const result = await originalMethod.apply(this, args)
      const duration = Date.now() - start
      
      if (duration > threshold) {
        console.warn(`慢方法: ${propertyKey} 耗时 ${duration}ms`)
      }
      return result
    }
  }
}
```

**📝 关键要点：**
- **target**：始终是被装饰的对象
- **propertyKey**：方法/属性的名称字符串
- **descriptor**：方法装饰器独有，用于修改方法行为
- **originalMethod.apply(this, args)**：调用原方法并保持this绑定

### 📖 第16天：模块系统与包管理

**📦 Node.js模块系统（必背）：**
```javascript
// CommonJS导出导入
module.exports = { name: 'test' }    // 完整替换
exports.name = 'test'                // 属性导出
const fs = require('fs')             // 导入模块

// ES6模块
export default class User {}         // 默认导出
export { UserService }              // 命名导出
import User from './user'            // 导入默认
import { UserService } from './user' // 导入命名
```

**🔄 CommonJS vs ES6模块（必记）：**
- **CommonJS**：运行时加载、值拷贝、同步加载、this指向当前模块
- **ES6模块**：编译时静态分析、值引用（活绑定）、异步加载、this指向undefined

**🎯 NestJS模块化设计（必背）：**
```typescript
@Module({
  imports: [DatabaseModule],    // 依赖模块
  controllers: [UserController], // 控制器
  providers: [UserService],     // 服务
  exports: [UserService]        // 对外导出
})

// 模块设计原则：
// 高内聚：模块内部功能紧密相关
// 低耦合：模块之间依赖关系简单
// 单一职责：一个模块负责一个业务领域
```

**📁 包管理器对比（必记）：**
- **npm**：官方包管理器，功能全面
- **yarn**：Facebook开发，更快更安全
- **pnpm**：节省磁盘空间，符号链接共享

**📝 关键概念：**
- **模块缓存**：require.cache存储已加载模块
- **循环依赖**：模块相互引用的处理机制
- **barrel导出**：用index.js统一导出模块内容

### 📖 第17天：Middleware（中间件）

**🔗 Middleware作用（必背）：**
```
1. 请求预处理
2. 跨域处理（CORS）
3. 请求日志记录
4. 请求限流
```

**⚡ Middleware vs Interceptor（必记）：**
- **Middleware**：请求进入应用前处理（更底层）
- **Interceptor**：请求进入Controller前后处理（更高层）
- **执行顺序**：Middleware → Guard → Interceptor → Controller

**🎯 Middleware类比（必背）：**
```
// 就像机场安检
Middleware = 安检门（所有人都要过）
Guard = 身份验证（检查护照）
Interceptor = 服务员（提供额外服务）
```

**📝 关键概念：**
- **请求管道**：请求经过多个处理器的流水线
- **全局处理**：对所有请求统一处理

### 📖 第18天：Pipe（管道）

**🚰 Pipe作用（必背）：**
```
1. 数据验证
2. 数据转换
3. 类型转换
4. 参数处理
```

**🔄 Pipe处理流程（必记）：**
```
客户端数据 → Pipe验证转换 → Controller接收
          ↓
      不合法就抛出异常
```

**🎯 常用Pipe类型（必背）：**
- **ValidationPipe**：数据验证管道
- **ParseIntPipe**：字符串转数字
- **ParseBoolPipe**：字符串转布尔
- **ParseUUIDPipe**：验证UUID格式

**📝 关键概念：**
- **数据流处理**：数据在传递过程中的变换
- **fail-fast原则**：发现错误立即停止

### 📖 第19天：Provider深入理解

**🏭 Provider概念（必背）：**
```
1. 可以被注入的任何值
2. 服务、工厂、值都是Provider
3. IoC容器管理Provider生命周期
4. 支持单例、请求作用域等模式
```

**🔧 Provider类型（必记）：**
- **Class Provider**：最常见，注入类实例
- **Value Provider**：注入固定值
- **Factory Provider**：动态创建值
- **Existing Provider**：为现有Provider创建别名

**🎯 Provider作用域（必背）：**
- **SINGLETON**：整个应用共享一个实例
- **REQUEST**：每个请求创建新实例
- **TRANSIENT**：每次注入都创建新实例

**📝 关键概念：**
- **控制反转**：不用手动创建对象，由容器管理
- **生命周期管理**：容器决定对象何时创建和销毁

### 📖 第20天：第二周总结

**🔧 核心组件职责总结（必背3遍）：**
1. **Controller**：HTTP入口，路由分发
2. **Service**：业务逻辑，核心处理
3. **Repository**：数据访问，查询封装
4. **DTO**：数据验证，接口契约
5. **Entity**：数据模型，ORM映射
6. **Guard**：权限控制，安全守护
7. **Interceptor**：横切处理，统一格式
8. **Middleware**：请求预处理，全局功能
9. **Pipe**：数据转换，参数验证

**🌐 网络通信基础总结（必背3遍）：**
1. **HTTP协议**：无状态请求响应，RESTful API设计
2. **TCP协议**：可靠连接，三次握手，适合数据传输
3. **UDP协议**：快速无连接，适合实时场景
4. **RPC通信**：远程过程调用，微服务内部通信
5. **协议分层**：应用层→传输层→网络层→链路层

---

## 📅 第3周：企业级特性

### 📖 第21天：异常处理

**🚨 异常处理思维（必背）：**
```
1. 预期错误：业务异常，可恢复
2. 意外错误：系统异常，需记录
3. 统一格式：所有错误统一响应格式
4. 用户友好：不暴露系统内部信息
```

**📋 异常分类（必记）：**
- **HttpException**：HTTP相关错误
- **BusinessException**：业务逻辑错误
- **ValidationException**：数据验证错误
- **SystemException**：系统级错误

**🔄 异常处理策略（必背）：**
```
1. 策略模式：不同类型异常不同处理
2. 责任链模式：异常逐级向上抛出
3. 记录追踪：记录错误日志便于调试
4. 优雅降级：服务异常时提供备选方案
```

**📝 关键概念：**
- **全局异常过滤器**：统一捕获和处理所有异常
- **错误码系统**：用编码标识不同类型的错误

### 📖 第22天：配置管理

**⚙️ 配置管理原则（必背）：**
```
1. 环境分离：开发/测试/生产配置分开
2. 敏感信息：密码/密钥不能写死在代码里
3. 类型安全：配置要有类型检查
4. 运行时验证：启动时检查配置是否正确
```

**🌍 环境变量使用（必记）：**
- `NODE_ENV`：运行环境（development/production）
- `PORT`：服务端口
- `DATABASE_URL`：数据库连接
- `JWT_SECRET`：JWT签名密钥

**🔧 配置模式（必背）：**
- **层级配置**：基础配置+环境配置+本地配置
- **配置验证**：启动时检查配置完整性
- **动态配置**：运行时可修改的配置
- **配置中心**：统一管理多服务配置

**📝 关键概念：**
- **12因子应用**：配置与代码分离的最佳实践
- **配置即代码**：配置文件版本化管理

### 📖 第23天：日志系统

**📝 日志级别（必背）：**
```
ERROR: 错误信息，需要立即处理
WARN:  警告信息，需要关注
INFO:  一般信息，记录业务流程
DEBUG: 调试信息，开发时使用
```

**🎯 日志内容（必记）：**
- **请求日志**：记录所有API调用
- **错误日志**：记录所有异常信息
- **业务日志**：记录重要业务操作
- **性能日志**：记录接口响应时间

**🔍 日志最佳实践（必背）：**
```
1. 结构化日志：使用JSON格式便于解析
2. 关联ID：每个请求有唯一标识便于追踪
3. 敏感信息过滤：不记录密码、token等
4. 日志轮转：定期清理旧日志节省空间
```

**📝 关键概念：**
- **链路追踪**：跟踪请求在系统中的完整路径
- **日志聚合**：集中收集和分析多服务日志

### 📖 第24天：认证授权

**🔑 JWT认证流程（必背）：**
```
1. 用户登录 → 验证账密
2. 生成JWT → 包含用户信息
3. 返回Token → 前端存储
4. 后续请求 → 携带Token
5. 服务器验证 → 解析用户信息
```

**🛡️ 安全原则（必记）：**
- **密码加密**：永远不存储明文密码
- **Token过期**：JWT要设置合理过期时间
- **HTTPS传输**：敏感信息必须加密传输
- **最小权限**：用户只能访问必要的资源

**🔐 认证授权模式（必背）：**
- **基于角色（RBAC）**：用户有角色，角色有权限
- **基于属性（ABAC）**：根据用户、资源、环境属性决定权限
- **JWT + Refresh Token**：短期访问令牌+长期刷新令牌
- **单点登录（SSO）**：一次登录多系统使用

**📝 关键概念：**
- **会话管理**：服务端如何记住用户状态
- **权限粒度**：从粗粒度到细粒度的权限控制

### 📖 第25天：数据库思维与事务

**💾 数据库操作（必背）：**
```
CREATE: 创建数据
READ:   查询数据
UPDATE: 更新数据
DELETE: 删除数据
```

**🔗 关系类型（必记）：**
- **一对一**：用户-用户资料
- **一对多**：用户-文章
- **多对多**：用户-角色

**⚡ 事务ACID特性（必背）：**
- **原子性（A）**：要么全做，要么全不做
- **一致性（C）**：数据始终保持一致状态
- **隔离性（I）**：并发事务不互相干扰
- **持久性（D）**：提交的数据永久保存

**🎯 事务隔离级别（必记）：**
- **读未提交**：可能脏读，性能最好
- **读已提交**：避免脏读，可能重复读
- **可重复读**：避免重复读，可能幻读
- **串行化**：最高隔离级别，性能最差

**📝 关键概念：**
- **乐观锁**：假设不会冲突，冲突时重试
- **悲观锁**：假设会冲突，先锁定再操作

### 📖 第26天：缓存与存储策略

**💾 缓存层次架构（必背）：**
```
L1: 应用内缓存（本地缓存）
- 进程内存、本地Map、LRU Cache
- 速度最快，容量有限，不能跨进程共享
- 例：Node.js Map、Java Caffeine

L2: 分布式缓存（远程缓存）  
- Redis、Memcached
- 容量大，有网络延迟，支持多实例共享
- 支持集群、持久化、数据结构丰富

L3: 数据库缓存
- MySQL Query Cache、InnoDB Buffer Pool
- 数据库层面自动优化

L4: 文件系统缓存
- 操作系统页缓存（Page Cache）
- 磁盘I/O优化，透明缓存机制
```

**🔥 缓存问题与解决（必记）：**
```
1. 缓存穿透：
   - 问题：查询不存在的数据，直击数据库
   - 解决：布隆过滤器、空值缓存

2. 缓存击穿：
   - 问题：热点数据过期，并发直击数据库
   - 解决：互斥锁、永不过期+异步更新

3. 缓存雪崩：
   - 问题：大量缓存同时过期
   - 解决：过期时间随机化、多级缓存
```

**⚡ 缓存更新策略（必背）：**
- **Cache-Aside（旁路缓存）**：应用负责缓存管理
- **Write-Through（直写）**：同时写缓存和数据库
- **Write-Back（回写）**：先写缓存，延迟写数据库
- **Refresh-Ahead（预刷新）**：主动刷新即将过期的数据

**🎯 存储技术选型（必记）：**
```
关系型数据库（RDBMS）：
- MySQL、PostgreSQL
- ACID特性、强一致性
- 适合：事务场景、复杂查询

NoSQL数据库：
- 文档型：MongoDB（JSON文档）
- 键值型：Redis（缓存、会话）
- 列族型：Cassandra（时序数据）  
- 图数据库：Neo4j（关系图谱）

选型原则：
- 数据结构复杂度
- 一致性要求
- 扩展性需求
- 查询模式
```

**📝 关键概念：**
- **缓存一致性**：缓存与数据库数据保持同步
- **数据库分片**：水平分割数据到多个数据库
- **读写分离**：主库写入，从库查询

### 📖 第27天：性能优化与监控

**⚡ 性能优化策略（必背）：**
```
1. 数据库优化：索引、查询优化
2. 缓存策略：Redis、内存缓存
3. 分页查询：避免一次查询太多数据
4. 连接池：复用数据库连接
```

**📊 监控指标（必记）：**
- **响应时间**：接口处理时间
- **吞吐量**：每秒处理请求数
- **错误率**：失败请求占比
- **资源使用**：CPU、内存使用情况

**🎯 性能优化技术（必背）：**
- **数据库层面**：索引优化、查询优化、分库分表
- **应用层面**：代码优化、算法优化、异步处理
- **架构层面**：负载均衡、微服务、分布式缓存
- **网络层面**：CDN、HTTP/2、压缩传输

**📈 APM监控（必记）：**
- **链路追踪**：跟踪请求完整路径
- **性能监控**：实时监控系统性能指标
- **错误监控**：自动捕获和告警异常
- **业务监控**：监控关键业务指标

**📝 关键概念：**
- **SLA/SLO/SLI**：服务等级协议、目标、指标
- **容量规划**：预估系统负载能力

### 📖 第28天：API设计与版本控制

**🌐 RESTful API设计原则（必背）：**
```
1. 资源导向：URL表示资源，HTTP方法表示操作
2. 无状态：每个请求包含所有必要信息
3. 统一接口：一致的请求响应格式
4. 分层系统：客户端无需知道服务器内部结构
```

**🔢 HTTP方法语义（必记）：**
- **GET**：获取资源，幂等，安全
- **POST**：创建资源，非幂等
- **PUT**：更新整个资源，幂等
- **PATCH**：部分更新资源，可能非幂等
- **DELETE**：删除资源，幂等

**🎯 API版本控制策略（必背）：**
- **URL版本控制**：`/api/v1/users`
- **Header版本控制**：`Accept: application/vnd.api.v1`
- **参数版本控制**：`/api/users?version=1`
- **域名版本控制**：`v1.api.example.com`

**📝 关键概念：**
- **向后兼容**：新版本不破坏旧客户端
- **API契约**：明确定义输入输出格式

### 📖 第29天：数据序列化与响应格式

**📦 数据序列化作用（必背）：**
```
1. 数据转换：对象转JSON格式
2. 字段过滤：隐藏敏感信息
3. 数据变换：格式化日期、数字等
4. 嵌套处理：处理关联对象
```

**🎯 响应格式标准化（必记）：**
```json
{
  "success": true,
  "data": {...},
  "message": "操作成功",
  "timestamp": "2024-01-01T10:00:00Z",
  "code": 200
}
```

**🔒 敏感信息过滤（必背）：**
- **@Exclude()**：排除敏感字段
- **@Transform()**：转换数据格式
- **@Expose()**：只暴露指定字段
- **@SerializeOptions()**：按策略序列化

**📝 关键概念：**
- **数据脱敏**：隐藏敏感信息的部分内容
- **响应拦截器**：统一处理所有响应格式

### 📖 第30天：并发编程与系统架构

**⚡ 并发基础概念（必背）：**
```
1. 进程（Process）：
   - 系统资源分配的基本单位
   - 拥有独立的内存空间
   - 进程间通信成本高（IPC）

2. 线程（Thread）：
   - 程序执行的基本单位
   - 共享进程内存空间
   - 线程间通信成本低

3. 协程（Coroutine）：
   - 用户态轻量级线程
   - 协作式调度，非抢占式
   - 适合IO密集型任务
```

**🔒 锁机制与并发安全（必记）：**
- **互斥锁（Mutex）**：同时只允许一个线程访问
- **读写锁（RW Lock）**：读共享，写排他
- **自旋锁（Spinlock）**：忙等待，适合短期锁定
- **分布式锁**：跨进程、跨机器的锁机制

**🏗️ 架构模式演进（必背）：**
```
单体架构 = 小餐馆：
- 一个厨师做所有菜（所有功能一个应用）
- 简单高效（开发简单）
- 规模有限（扩展困难）

微服务架构 = 连锁餐厅：
- 专业分工（每个服务专注一个功能）
- 独立运营（独立部署扩展）
- 管理复杂（分布式挑战）

架构演进路径：
单体应用 → 分层单体 → 服务化单体 → 微服务架构
```

**🎯 并发安全问题（必记）：**
- **竞态条件**：多线程同时访问共享资源
- **死锁**：线程相互等待对方释放资源
- **活锁**：线程一直在运行但无法推进
- **饥饿**：线程长期无法获得所需资源

**📝 关键概念：**
- **原子操作**：不可分割的操作单元
- **服务边界**：按业务能力划分服务
- **数据隔离**：每个服务管理自己的数据

### 📖 第31天：消息队列与事件驱动

**📨 消息队列基础（必背）：**
```
1. 点对点模式（Queue）：
   - 一对一消息传递
   - 消息只被一个消费者处理
   - 例：订单处理、任务分发

2. 发布订阅模式（Topic）：
   - 一对多消息传递  
   - 消息被多个订阅者处理
   - 例：事件通知、数据同步

3. 消息队列作用：
   - 异步处理：提高响应速度
   - 削峰填谷：处理流量突增
   - 系统解耦：服务间松耦合
```

**⚡ 主流消息队列对比（必记）：**
- **RabbitMQ**：功能丰富、路由灵活、支持多种协议（AMQP/MQTT）
- **Apache Kafka**：高吞吐、分布式、适合日志流处理
- **Redis Streams**：轻量级、高性能、支持消费组（Pub/Sub较简单）
- **RocketMQ**：阿里开源、事务消息、顺序消息、金融级可靠性

**🔄 事件驱动架构（必背）：**
```
事件（Event）= 系统中发生的重要事情
事件源（Event Source）= 产生事件的组件
事件处理器（Event Handler）= 处理事件的组件

优点：
- 松耦合：组件间不直接依赖
- 高扩展：新增事件处理器简单
- 异步处理：提高系统响应性

缺点：
- 调试困难：事件链路复杂
- 数据一致性：事件可能丢失或重复
- 复杂性：系统架构更复杂
```

**🎯 消息可靠性保证（必背）：**
```
1. 生产者可靠性：
   - 确认机制（ACK）
   - 重试机制
   - 本地事务表

2. 消息持久化：
   - 内存队列 vs 磁盘队列
   - 数据备份和恢复

3. 消费者可靠性：
   - 手动确认消费
   - 幂等性处理
   - 死信队列处理
```

**📝 关键概念：**
- **消息幂等性**：重复消费同一消息结果一致
- **消息顺序性**：保证消息按顺序处理
- **背压处理**：消费速度跟不上生产速度的处理

### 📖 第32天：分布式系统与微服务

**🌐 分布式系统挑战（必背）：**
```
1. 网络分区（Network Partition）
   - 网络故障导致节点间无法通信
   - 需要在一致性和可用性间权衡

2. 节点故障（Node Failure）
   - 机器宕机、进程崩溃
   - 需要故障检测和恢复机制

3. 时钟不同步（Clock Skew）
   - 不同机器时间不一致
   - 影响事件顺序判断
```

**⚖️ CAP定理（必背）：**
```
C (Consistency): 一致性
- 所有节点看到相同数据
- 强一致性 vs 最终一致性

A (Availability): 可用性  
- 系统持续提供服务
- 服务可用时间百分比

P (Partition Tolerance): 分区容错
- 网络分区时仍能工作
- 分布式系统必须具备

定理：最多只能同时保证三个特性中的两个
```

**🏗️ 微服务架构模式（必背）：**
```
单体应用 vs 微服务对比：

单体应用（Monolith）：
- 所有功能在一个应用中
- 部署简单、开发效率高
- 技术栈统一、事务简单
- 适合：小团队、简单业务、MVP

微服务（Microservices）：
- 功能按业务拆分服务
- 独立部署、技术栈自由
- 分布式复杂、数据一致性挑战
- 适合：大团队、复杂业务、高并发
```

**🔄 一致性模型（必记）：**
- **强一致性**：所有节点同时看到更新
- **弱一致性**：不保证什么时候一致
- **最终一致性**：保证最终会一致
- **因果一致性**：有因果关系的操作保持顺序

**📝 关键概念：**
- **服务边界**：按业务能力划分服务
- **数据隔离**：每个服务管理自己的数据
- **去中心化**：避免单点故障

### 📖 第33天：系统设计模式

**🛡️ 系统可靠性模式（必背）：**
```
1. 熔断器模式（Circuit Breaker）：
   - 监控服务调用失败率
   - 失败率超阈值时"熔断"
   - 状态：关闭→打开→半开
   - 防止故障传播

2. 限流模式（Rate Limiting）：
   - 控制请求频率
   - 算法：令牌桶、漏桶、固定窗口、滑动窗口
   - 保护系统不被压垮

3. 重试模式（Retry Pattern）：
   - 暂时性故障自动重试
   - 指数退避算法
   - 最大重试次数限制
```

**⚖️ 负载均衡策略（必记）：**
- **轮询（Round Robin）**：依次分配请求
- **随机（Random）**：随机选择服务器
- **最少连接（Least Connections）**：选择连接数最少的
- **加权轮询**：根据服务器性能分配权重
- **IP哈希**：根据客户端IP哈希选择

**🎯 监控与可观测性（必背）：**
```
监控三大支柱：
1. Metrics（指标）：
   - 数值型数据：QPS、延迟、错误率
   - 时间序列数据库：Prometheus

2. Logging（日志）：
   - 事件记录：请求日志、错误日志
   - 集中化管理：ELK Stack

3. Tracing（链路追踪）：
   - 请求在系统中的完整路径
   - 分布式追踪：Jaeger、Zipkin

黄金指标：
- 延迟（Latency）
- 流量（Traffic）  
- 错误（Errors）
- 饱和度（Saturation）
```

**🏗️ 扩展性设计模式（必记）：**
```
水平扩展（Scale Out）：
- 增加服务器数量
- 负载均衡分发请求
- 无状态服务设计

垂直扩展（Scale Up）：
- 增加服务器配置
- CPU、内存、磁盘升级
- 有天花板限制

数据库扩展：
- 主从复制：读写分离
- 分库分表：数据水平切分
- 分布式数据库：自动分片
```

**📝 关键概念：**
- **优雅降级**：部分功能不可用时保证核心功能
- **故障隔离**：故障不影响其他模块
- **容量规划**：根据业务增长预估资源需求

### 📖 第34天：通用后端总结与进阶

**🧠 后端思维体系总结（必背5遍）：**

**1. 架构思维：**
- 分层架构：Controller → Service → Repository → Database
- 模块化：按业务领域划分模块，单体→微服务演进
- 依赖注入：让框架管理对象生命周期
- 服务边界：业务驱动的服务拆分策略

**2. 数据思维：**
- 数据中心：一切围绕数据的CRUD操作
- 数据安全：验证、加密、权限控制
- 数据一致性：事务、约束、关系完整性
- 存储选型：关系型DB vs NoSQL，缓存策略

**3. 服务思维：**
- 无状态：每个请求都是独立的
- 幂等性：相同操作多次执行结果一致
- 容错性：熔断、重试、限流机制
- 分布式：CAP定理，一致性模型

**4. 并发思维：**
- 进程线程协程：不同并发模型的选择
- 锁与同步：互斥锁、读写锁、分布式锁
- 并发安全：竞态条件、死锁避免
- 异步处理：消息队列、事件驱动

**5. 安全思维：**
- 不信任客户端：所有数据都要验证
- 最小权限：用户只能访问必要资源
- 防御编程：预期各种攻击和异常
- 认证授权：JWT、OAuth、RBAC权限模型

**6. 运维思维：**
- 可观测性：日志、监控、链路追踪
- 可扩展性：水平扩展、负载均衡策略
- 可维护性：代码规范、文档完善
- 系统设计：高可用、高性能、高并发

**🎯 高级概念总结（必背3遍）：**
1. **请求生命周期**：Middleware → Guard → Interceptor → Pipe → Controller → Service → Repository
2. **异常处理链**：全局过滤器 → 策略模式 → 统一响应格式
3. **安全防护体系**：认证 → 授权 → 数据验证 → 错误处理
4. **性能优化体系**：缓存 → 数据库优化 → 连接池 → 监控告警
5. **数据流转链路**：DTO验证 → Service处理 → Repository查询 → 序列化响应
6. **分布式系统核心**：CAP定理 → 一致性模型 → 服务发现 → 负载均衡
7. **架构演进路径**：单体 → 分层 → SOA → 微服务 → 云原生
8. **并发处理模式**：多线程 → 协程 → 事件驱动 → 响应式编程
9. **缓存体系架构**：L1本地 → L2分布式 → L3数据库 → L4系统级
10. **可观测性体系**：Metrics指标 → Logging日志 → Tracing链路



## 📅 第4周：开发套路实战（简化版）

### 📖 第35天：NestJS开发套路

**🎯 模块创建套路（必背）：**
```typescript
// 1. 创建模块文件结构
users/
├── controllers/     // HTTP接口层
├── services/       // 业务逻辑层
├── dtos/          // 数据传输对象
├── entities/      // 数据实体
├── interfaces/    // 接口定义
├── users.module.ts
└── index.ts       // 统一导出

// 2. 标准模块定义
@Module({
  imports: [MikroOrmModule.forFeature([User])],
  controllers: [UsersController],
  providers: [UsersService, UsersRepository],
  exports: [UsersService]
})
```

**🔧 依赖注入套路（必记）：**
```typescript
// 服务注入套路
@Injectable()
export class UsersService {
  constructor(
    private readonly usersRepo: UsersRepository,
    private readonly configService: ConfigService,
    private readonly logger: LoggerService
  ) {}
}

// 条件注入套路
@Injectable()
export class NotificationService {
  constructor(
    @Inject('EMAIL_SERVICE') private emailService: EmailService,
    @Optional() @Inject('SMS_SERVICE') private smsService?: SmsService
  ) {}
}
```

**🎯 错误处理套路（必背）：**
```typescript
// 业务异常抛出套路
if (!user) {
  throw new NotFoundException('用户不存在')
}

if (user.isBlocked) {
  throw new ForbiddenException('用户已被封禁')
}

// 参数验证套路
if (!createUserDto.email) {
  throw new BadRequestException('邮箱不能为空')
}
```

**📝 关键套路：**
- **模块先行**：先设计模块结构，再写具体实现
- **接口定义**：用TypeScript接口约束数据结构
- **异常分类**：业务异常、验证异常、系统异常分开处理

### 📖 第36天：MikroORM与数据库操作

**🏛️ Entity定义套路（必背）：**
```typescript
// 基础实体继承套路
@Entity({ abstract: true })
export abstract class BaseEntity {
  @PrimaryKey()
  id!: number

  @Property()
  createdAt: Date = new Date()

  @Property({ onUpdate: () => new Date() })
  updatedAt: Date = new Date()
}

// 业务实体定义套路
@Entity({ tableName: 'users' })
export class User extends BaseEntity {
  @Property({ length: 50 })
  @Unique()
  username!: string

  @Property({ length: 100 })
  @Unique()
  email!: string

  @Property({ nullable: true })
  nickname?: string
}
```

**🔍 查询操作套路（必记）：**
```typescript
// Repository基础查询套路
export class UsersRepository {
  constructor(private readonly em: EntityManager) {}

  // 基础CRUD套路
  async findAll(): Promise<User[]> {
    return this.em.find(User, {})
  }

  async findById(id: number): Promise<User> {
    const user = await this.em.findOne(User, { id })
    if (!user) {
      throw new NotFoundException('用户不存在')
    }
    return user
  }

  async create(userData: CreateUserDto): Promise<User> {
    const user = new User()
    user.username = userData.username
    user.email = userData.email
    
    await this.em.persistAndFlush(user)
    return user
  }
}
```

**⚡ 高级查询套路（必背）：**
```typescript
// 分页查询套路
async findWithPagination(page: number, limit: number) {
  const offset = (page - 1) * limit
  
  const [items, total] = await Promise.all([
    this.em.find(User, {}, { 
      orderBy: { createdAt: 'DESC' }, 
      limit, 
      offset 
    }),
    this.em.count(User)
  ])
  
  return {
    data: items,
    meta: { page, limit, total, totalPages: Math.ceil(total / limit) }
  }
}

// 条件查询套路
async searchUsers(keyword: string) {
  return this.em.find(User, {
    $or: [
      { username: { $like: `%${keyword}%` } },
      { email: { $like: `%${keyword}%` } }
    ]
  })
}
```

**🔄 事务处理套路（必背）：**
```typescript
// 事务操作套路
async transferPoints(fromId: number, toId: number, points: number) {
  await this.em.transactional(async (em) => {
    const fromUser = await em.findOne(User, { id: fromId })
    const toUser = await em.findOne(User, { id: toId })
    
    fromUser.points -= points
    toUser.points += points
    
    // 自动提交，出错自动回滚
  })
}
```

**📝 关键套路：**
- **实体先行**：先定义实体，再写查询逻辑
- **类型安全**：充分利用TypeScript类型检查
- **事务包装**：涉及多表操作必须用事务

### 📖 第37天：企业级开发总结

**🏭 工厂模式套路（必背）：**
```typescript
// 策略工厂模式
@Injectable()
export class NotificationFactory {
  create(type: 'email' | 'sms' | 'push'): NotificationService {
    switch (type) {
      case 'email':
        return new EmailNotificationService()
      case 'sms':
        return new SmsNotificationService()
      case 'push':
        return new PushNotificationService()
      default:
        throw new Error('不支持的通知类型')
    }
  }
}
```

**🎯 策略模式套路（必记）：**
```typescript
// 支付策略模式
interface PaymentStrategy {
  pay(amount: number): Promise<PaymentResult>
}

@Injectable()
export class AlipayStrategy implements PaymentStrategy {
  async pay(amount: number): Promise<PaymentResult> {
    // 支付宝支付逻辑
  }
}

@Injectable()
export class WechatStrategy implements PaymentStrategy {
  async pay(amount: number): Promise<PaymentResult> {
    // 微信支付逻辑
  }
}
```

**🔗 装饰器模式套路（必背）：**
```typescript
// 缓存装饰器套路
export function Cacheable(ttl: number = 300) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value
    
    descriptor.value = async function (...args: any[]) {
      const cacheKey = `${propertyKey}:${JSON.stringify(args)}`
      
      // 先查缓存
      let result = await this.cacheService.get(cacheKey)
      if (!result) {
        // 缓存不存在，执行原方法
        result = await originalMethod.apply(this, args)
        await this.cacheService.set(cacheKey, result, ttl)
      }
      
      return result
    }
  }
}

// 使用装饰器
@Cacheable(600)
async getUserById(id: number) {
  return this.usersRepository.findById(id)
}
```

**📝 关键套路：**
- **接口抽象**：用接口定义行为契约
- **依赖注入**：通过构造函数注入依赖
- **装饰增强**：用装饰器增强方法功能

### 📖 第38天：API开发最佳实践

**🌐 Controller标准写法（必背）：**
```typescript
@Controller('api/users')
@ApiTags('用户管理')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Get()
  @ApiOperation({ summary: '获取用户列表' })
  @ApiQuery({ name: 'page', required: false, description: '页码' })
  async findAll(
    @Query('page', new DefaultValuePipe(1), ParseIntPipe) page: number,
    @Query('limit', new DefaultValuePipe(10), ParseIntPipe) limit: number
  ) {
    return this.usersService.findWithPagination(page, limit)
  }

  @Post()
  @ApiOperation({ summary: '创建用户' })
  @ApiBody({ type: CreateUserDto })
  async create(@Body() createUserDto: CreateUserDto) {
    return this.usersService.create(createUserDto)
  }

  @Get(':id')
  @ApiOperation({ summary: '获取用户详情' })
  @ApiParam({ name: 'id', description: '用户ID' })
  async findOne(@Param('id', ParseIntPipe) id: number) {
    return this.usersService.findById(id)
  }
}
```

**📝 DTO验证套路（必记）：**
```typescript
// 创建DTO
export class CreateUserDto {
  @ApiProperty({ description: '用户名', minLength: 2, maxLength: 50 })
  @IsString()
  @MinLength(2, { message: '用户名长度至少2位' })
  @MaxLength(50, { message: '用户名长度不超过50位' })
  username!: string

  @ApiProperty({ description: '邮箱地址' })
  @IsEmail({}, { message: '请输入有效的邮箱地址' })
  email!: string

  @ApiProperty({ description: '昵称', required: false })
  @IsOptional()
  @IsString()
  nickname?: string
}

// 更新DTO
export class UpdateUserDto extends PartialType(CreateUserDto) {}
```

**🔒 权限控制套路（必背）：**
```typescript
// 认证守卫套路
@Controller('api/users')
@UseGuards(JwtAuthGuard)  // 需要登录
export class UsersController {
  
  @Get('profile')
  @UseGuards(RolesGuard)  // 需要特定角色
  @Roles('user', 'admin')
  async getProfile(@Request() req) {
    return req.user
  }

  @Delete(':id')
  @UseGuards(RolesGuard)
  @Roles('admin')  // 只有管理员可以删除
  async remove(@Param('id') id: number) {
    return this.usersService.remove(id)
  }
}
```

**📝 关键套路：**
- **Swagger文档**：每个接口都要加API文档注解
- **参数验证**：使用Pipe进行参数类型转换和验证
- **权限分层**：认证→角色→具体权限的分层控制

### 📖 第39天：调试与测试套路

**🐛 调试技巧套路（必背）：**
```typescript
// 日志调试套路
@Injectable()
export class UsersService {
  private readonly logger = new Logger(UsersService.name)

  async create(createUserDto: CreateUserDto) {
    this.logger.log(`创建用户: ${JSON.stringify(createUserDto)}`)
    
    try {
      const user = await this.usersRepository.create(createUserDto)
      this.logger.log(`用户创建成功: ${user.id}`)
      return user
    } catch (error) {
      this.logger.error(`用户创建失败: ${error.message}`, error.stack)
      throw error
    }
  }
}

// 性能调试套路
@Injectable()
export class PerformanceInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler) {
    const start = Date.now()
    const request = context.switchToHttp().getRequest()
    
    return next.handle().pipe(
      tap(() => {
        const duration = Date.now() - start
        if (duration > 1000) {  // 超过1秒的慢查询
          console.warn(`慢查询警告: ${request.url} 耗时 ${duration}ms`)
        }
      })
    )
  }
}
```

**🧪 单元测试套路（必记）：**
```typescript
// Service测试套路
describe('UsersService', () => {
  let service: UsersService
  let repository: UsersRepository

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [
        UsersService,
        {
          provide: UsersRepository,
          useValue: {
            findById: jest.fn(),
            create: jest.fn(),
            update: jest.fn(),
          }
        }
      ]
    }).compile()

    service = module.get<UsersService>(UsersService)
    repository = module.get<UsersRepository>(UsersRepository)
  })

  it('应该能创建用户', async () => {
    const createDto = { username: 'test', email: 'test@example.com' }
    const expectedUser = { id: 1, ...createDto }
    
    jest.spyOn(repository, 'create').mockResolvedValue(expectedUser)
    
    const result = await service.create(createDto)
    
    expect(result).toEqual(expectedUser)
    expect(repository.create).toHaveBeenCalledWith(createDto)
  })
})
```

**🎯 E2E测试套路（必背）：**
```typescript
// E2E测试套路
describe('UsersController (e2e)', () => {
  let app: INestApplication

  beforeEach(async () => {
    const moduleFixture = await Test.createTestingModule({
      imports: [AppModule]
    }).compile()

    app = moduleFixture.createNestApplication()
    await app.init()
  })

  it('/api/users (GET)', () => {
    return request(app.getHttpServer())
      .get('/api/users')
      .expect(200)
      .expect((res) => {
        expect(res.body.data).toBeDefined()
        expect(Array.isArray(res.body.data)).toBe(true)
      })
  })

  it('/api/users (POST)', () => {
    return request(app.getHttpServer())
      .post('/api/users')
      .send({ username: 'test', email: 'test@example.com' })
      .expect(201)
      .expect((res) => {
        expect(res.body.data.id).toBeDefined()
        expect(res.body.data.username).toBe('test')
      })
  })
})
```

**📝 关键套路：**
- **日志先行**：关键操作都要记录日志
- **模拟依赖**：单元测试要模拟所有外部依赖
- **真实场景**：E2E测试要模拟真实的用户操作

### 📖 第40天：项目结构与规范套路

**📁 项目结构套路（必背）：**
```
src/
├── config/              # 配置文件
│   ├── app.config.ts    # 应用配置
│   ├── database.config.ts # 数据库配置
│   └── index.ts         # 配置统一导出
├── shared/              # 共享模块
│   ├── decorators/      # 自定义装饰器
│   ├── filters/         # 全局过滤器
│   ├── guards/          # 全局守卫
│   ├── interceptors/    # 全局拦截器
│   ├── pipes/           # 全局管道
│   └── utils/           # 工具函数
├── modules/             # 业务模块
│   ├── auth/            # 认证模块
│   ├── users/           # 用户模块
│   └── common/          # 通用模块
├── migrations/          # 数据库迁移
├── app.module.ts        # 根模块
└── main.ts             # 应用入口
```

**🔧 代码组织套路（必记）：**
```typescript
// 每个模块的index.ts统一导出
export * from './users.service'
export * from './users.controller'
export * from './users.module'
export * from './dtos'
export * from './entities'

// 使用barrel导出简化导入
// 好的方式
import { UsersService, CreateUserDto } from '@/modules/users'

// 不好的方式
import { UsersService } from '@/modules/users/users.service'
import { CreateUserDto } from '@/modules/users/dtos/create-user.dto'
```

**📝 命名规范套路（必背）：**
```
# 文件命名规范
users.controller.ts      # 控制器
users.service.ts         # 服务
users.module.ts          # 模块
user.entity.ts           # 实体（单数）
create-user.dto.ts       # DTO
users.repository.ts      # 仓储

# 类命名规范
UsersController          # 控制器类
UsersService            # 服务类
User                    # 实体类
CreateUserDto           # DTO类
UsersRepository         # 仓储类

# 方法命名规范
findAll()               # 查询所有
findById()              # 根据ID查询
create()                # 创建
update()                # 更新
remove()                # 删除（推荐用remove而不是delete）
```

**🎯 异常处理规范（必背）：**
```typescript
// 异常分类规范
export enum ErrorCode {
  // 用户相关 1000-1999
  USER_NOT_FOUND = 1001,
  USER_ALREADY_EXISTS = 1002,
  USER_BLOCKED = 1003,
  
  // 认证相关 2000-2999
  INVALID_TOKEN = 2001,
  TOKEN_EXPIRED = 2002,
  PERMISSION_DENIED = 2003,
  
  // 业务相关 3000-3999
  INSUFFICIENT_BALANCE = 3001,
  ORDER_NOT_FOUND = 3002,
}

// 自定义业务异常
export class BusinessException extends HttpException {
  constructor(code: ErrorCode, message: string) {
    super({ code, message }, HttpStatus.BAD_REQUEST)
  }
}
```

**📝 关键套路：**
- **模块化组织**：按业务领域划分模块，不按技术层次
- **统一导出**：使用index.ts文件统一导出模块内容
- **命名一致**：文件名、类名、方法名保持一致的命名风格

### 📖 第41天：开发套路总结与实战清单

**🚀 NestJS开发核心套路（必背5遍）：**
1. **模块驱动开发**：先设计模块结构，再实现具体功能
2. **依赖注入优先**：所有依赖通过构造函数注入，不手动创建
3. **装饰器声明式**：用装饰器声明路由、验证、权限等
4. **异常统一处理**：业务异常、验证异常、系统异常分类处理
5. **接口契约明确**：用DTO定义接口输入输出，用Entity定义数据模型

**🏛️ MikroORM使用核心套路（必背5遍）：**
1. **实体继承模式**：基础实体定义通用字段，业务实体继承扩展
2. **Repository封装**：数据访问逻辑封装在Repository中，Service调用
3. **事务边界清晰**：涉及多表操作必须包装在事务中
4. **查询类型安全**：充分利用TypeScript类型系统避免运行时错误
5. **关系映射规范**：明确定义实体间的一对一、一对多、多对多关系

**📋 实战开发清单（必记）：**

**🎯 开始新功能时：**
- [ ] 设计模块目录结构
- [ ] 定义Entity和关系
- [ ] 创建DTO验证规则
- [ ] 实现Repository数据访问
- [ ] 编写Service业务逻辑
- [ ] 实现Controller接口
- [ ] 添加Swagger文档
- [ ] 编写单元测试

**🔧 代码review清单：**
- [ ] 是否有统一的错误处理
- [ ] 是否有适当的日志记录
- [ ] 是否有参数验证
- [ ] 是否有权限控制
- [ ] 是否有事务处理
- [ ] 是否有性能考虑
- [ ] 是否符合命名规范

**🐛 调试问题时：**
- [ ] 检查日志输出
- [ ] 验证数据库查询
- [ ] 确认参数传递
- [ ] 检查异常堆栈
- [ ] 验证权限配置
- [ ] 测试边界条件

**🚀 性能优化时：**
- [ ] 添加适当缓存
- [ ] 优化数据库查询
- [ ] 检查N+1查询问题
- [ ] 考虑分页处理
- [ ] 监控接口性能
- [ ] 优化日志输出

**🔒 安全检查时：**
- [ ] 验证输入参数
- [ ] 检查权限控制
- [ ] 确认敏感信息过滤
- [ ] 验证SQL注入防护
- [ ] 检查认证流程
- [ ] 确认HTTPS传输

---

## 📅 第5周：Node.js底层知识体系（可选扩展）

### 📖 第42天：Node.js基础概念与运行时

**🚀 Node.js核心特性（必背）：**
```
1. JavaScript运行时：
   - 基于Chrome V8引擎（JavaScript解析执行）
   - 基于libuv（异步I/O事件循环）
   - 主线程单线程，I/O操作使用线程池
   - 非阻塞I/O操作

2. 设计理念：
   - 高并发、低延迟
   - 适合I/O密集型应用
   - CPU密集型可用Worker Threads或子进程
   - 事件驱动编程模型
```

**⚡ Node.js vs 浏览器差异（必记）：**
- **运行环境**：Node.js = V8 + libuv，浏览器 = V8 + DOM + BOM
- **API差异**：Node.js有fs、path、http等模块，浏览器有window、document等
- **模块系统**：Node.js支持CommonJS/ES6模块，浏览器主要支持ES6模块
- **全局对象**：Node.js是global，浏览器是window

**🎯 Node.js架构层次（必背）：**
```
应用代码（JavaScript）
     ↓
Node.js API（fs、http、crypto等）
     ↓
Node.js绑定层（C++绑定）
     ↓
V8引擎 + libuv + 其他C++库
     ↓
操作系统（文件系统、网络等）
```

**🏭 生活化类比（必背）：**
```
Node.js = 咖啡店服务员：
- 单线程（一个服务员）
- 事件驱动（客人点单就处理）
- 非阻塞（下单给后厨后继续接待客人）
- 高并发（同时服务多个客人）

V8引擎 = 服务员的大脑（理解和执行指令）
libuv = 传菜系统（处理异步任务）
事件循环 = 服务员的工作流程
```

**📝 关键概念：**
- **事件驱动**：通过事件和回调处理异步操作
- **非阻塞I/O**：不等待I/O操作完成，继续执行其他任务
- **单线程**：主线程单一，但有线程池处理I/O操作

### 📖 第43天：事件循环机制深入

**🔄 事件循环核心原理（必背）：**
```
事件循环六个阶段（按顺序执行）：
1. Timer阶段：执行setTimeout、setInterval回调
2. Pending阶段：执行系统相关回调
3. Idle/Prepare阶段：内部使用
4. Poll阶段：获取新的I/O事件，执行相关回调
5. Check阶段：执行setImmediate回调
6. Close阶段：关闭事件的回调

每个阶段都有回调队列，FIFO执行
```

**⚡ 微任务与宏任务（必记）：**
- **微任务（Microtask）**：
  - Promise.then/catch/finally
  - process.nextTick（最高优先级）
  - queueMicrotask
  - 每个宏任务结束后立即执行所有微任务

- **宏任务（Macrotask）**：
  - setTimeout/setInterval
  - setImmediate
  - I/O操作回调
  - 一次事件循环只执行一个宏任务

**🎯 执行优先级（必背）：**
```
同步代码 → process.nextTick → Promise微任务 → setImmediate → setTimeout

示例执行顺序：
console.log('1')                    // 1
setTimeout(() => console.log('2'))  // 6  
Promise.resolve().then(() => console.log('3'))  // 4
process.nextTick(() => console.log('4'))  // 3
setImmediate(() => console.log('5'))  // 5
console.log('6')                    // 2

注：setTimeout vs setImmediate顺序取决于事件循环阶段
```

**🎭 生活化类比（必背）：**
```
事件循环 = 银行柜台工作流程：
1. Timer阶段 = 处理预约客户（定时任务）
2. Poll阶段 = 等待和处理现场客户（I/O事件）
3. Check阶段 = 处理VIP客户（setImmediate）

process.nextTick = 插队的紧急客户（最高优先级）
Promise = 柜台内部事务（微任务优先）
setTimeout = 预约客户（按时间排队）
```

**📝 关键概念：**
- **Call Stack**：函数调用栈，同步代码执行
- **Event Queue**：事件队列，异步回调等待执行
- **Libuv**：负责异步I/O操作的C++库

### 📖 第44天：模块系统与包管理

**📦 CommonJS模块系统（必背）：**
```javascript
// 导出方式
module.exports = { name: 'test' }    // 完整替换
exports.name = 'test'                // 属性导出

// 导入方式
const fs = require('fs')             // 内置模块
const utils = require('./utils')     // 相对路径
const lodash = require('lodash')     // npm包

// 模块解析规则
require('./file')      // 查找 ./file.js → ./file/index.js
require('lodash')      // 查找 node_modules/lodash
```

**🔄 ES6模块与CommonJS对比（必记）：**
- **CommonJS**：
  - 运行时加载（动态）
  - 值的拷贝
  - 同步加载
  - this指向当前模块

- **ES6模块**：
  - 编译时加载（静态）
  - 值的引用
  - 异步加载
  - this指向undefined

**🎯 模块缓存机制（必背）：**
```javascript
// 模块只会执行一次，后续require返回缓存
console.log(require.cache)  // 查看模块缓存
delete require.cache[require.resolve('./module')]  // 清除缓存

// require.resolve 获取模块完整路径
const modulePath = require.resolve('lodash')
```

**📁 npm生态系统（必记）：**
- **package.json**：项目元信息和依赖声明
- **node_modules**：依赖包存储目录
- **package-lock.json**：锁定依赖版本
- **npm scripts**：自定义脚本命令

**🎭 生活化类比（必背）：**
```
模块系统 = 图书馆：
- require() = 借书（获取知识）
- module.exports = 出版书籍（分享知识）
- node_modules = 藏书库（依赖存储）
- package.json = 图书目录（项目清单）

模块缓存 = 已读书籍记忆（不重复阅读）
```

**📝 关键概念：**
- **模块作用域**：每个模块有独立的作用域
- **循环依赖**：模块相互引用时的处理机制
- **语义化版本**：major.minor.patch版本规范

### 📖 第45天：文件系统与流操作

**📁 文件系统API分类（必背）：**
```javascript
// 同步操作（阻塞）
const data = fs.readFileSync('./file.txt', 'utf8')

// 异步回调（传统方式）
fs.readFile('./file.txt', 'utf8', (err, data) => {
  if (err) throw err
  console.log(data)
})

// Promise版本（现代方式）
const fsPromises = require('fs/promises')
const data = await fsPromises.readFile('./file.txt', 'utf8')

// 流式操作（大文件）
const stream = fs.createReadStream('./large-file.txt')
```

**💧 Stream流操作（必记）：**
- **Readable Stream**：可读流（读取数据源）
- **Writable Stream**：可写流（写入目标）
- **Duplex Stream**：双工流（既可读又可写）
- **Transform Stream**：转换流（读取→处理→写入）

**🎯 流的核心优势（必背）：**
```
1. 内存效率：分块处理，不需要加载整个文件
2. 时间效率：边读边处理，不等读完再处理
3. 处理大文件：可以处理超过内存限制的文件
4. 组合性：可以用管道连接多个流

// 流管道示例
fs.createReadStream('input.txt')
  .pipe(zlib.createGzip())        // 压缩
  .pipe(fs.createWriteStream('output.gz'))
```

**🔧 常用文件操作（必记）：**
```javascript
// 目录操作
fs.mkdirSync('./newDir', { recursive: true })  // 创建目录
fs.readdirSync('./dir')                         // 读取目录
fs.rmSync('./dir', { recursive: true })        // 删除目录

// 文件信息
const stats = fs.statSync('./file.txt')
stats.isFile()        // 是否文件
stats.isDirectory()   // 是否目录
stats.size           // 文件大小
stats.mtime          // 修改时间

// 路径操作
const path = require('path')
path.join('/a', 'b', 'c')           // /a/b/c
path.resolve('./file.txt')          // 绝对路径
path.extname('file.txt')            // .txt
path.basename('/a/b/file.txt')      // file.txt
```

**🎭 生活化类比（必背）：**
```
文件系统 = 图书馆管理：
- 同步读取 = 排队等书（阻塞其他人）
- 异步读取 = 预约取书（不阻塞）
- 流读取 = 分章节阅读（逐步处理）

Stream = 流水线生产：
- Readable = 原料输送带
- Transform = 加工处理站
- Writable = 成品收集站
- Pipe = 连接传送带
```

**📝 关键概念：**
- **背压（Backpressure）**：写入速度超过处理能力时的控制机制
- **错误处理**：stream.on('error', handler)处理流错误
- **文件描述符**：操作系统分配给文件的标识符

### 📖 第46天：网络编程与HTTP模块

**🌐 HTTP模块基础（必背）：**
```javascript
// 创建HTTP服务器
const http = require('http')
const server = http.createServer((req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/plain' })
  res.end('Hello World')
})
server.listen(3000)

// 发起HTTP请求
http.get('http://api.example.com', (res) => {
  let data = ''
  res.on('data', chunk => data += chunk)
  res.on('end', () => console.log(data))
})
```

**🔧 Request和Response对象（必记）：**
- **Request（req）对象**：
  - req.method：HTTP方法（GET、POST等）
  - req.url：请求路径
  - req.headers：请求头
  - req.on('data')：接收请求体数据

- **Response（res）对象**：
  - res.writeHead()：设置状态码和响应头
  - res.write()：写入响应体数据
  - res.end()：结束响应

**⚡ URL解析与查询参数（必背）：**
```javascript
const url = require('url')
const querystring = require('querystring')

// URL解析
const parsedUrl = url.parse('http://example.com:3000/path?name=test&age=20')
// {
//   protocol: 'http:',
//   host: 'example.com:3000',
//   pathname: '/path',
//   search: '?name=test&age=20'
// }

// 查询参数解析
const query = querystring.parse('name=test&age=20')
// { name: 'test', age: '20' }
```

**🔐 HTTPS与加密（必记）：**
```javascript
const https = require('https')
const fs = require('fs')

// 创建HTTPS服务器
const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('certificate.pem')
}

https.createServer(options, (req, res) => {
  res.writeHead(200)
  res.end('Secure connection')
}).listen(443)
```

**🎯 WebSocket支持（必背）：**
```javascript
// WebSocket握手升级
server.on('upgrade', (request, socket, head) => {
  if (request.headers.upgrade === 'websocket') {
    // 处理WebSocket连接
    handleWebSocket(request, socket, head)
  }
})

// Socket连接处理
const net = require('net')
const server = net.createServer((socket) => {
  socket.on('data', (data) => {
    console.log('Received:', data.toString())
    socket.write('Echo: ' + data)
  })
})
```

**🎭 生活化类比（必背）：**
```
HTTP服务器 = 餐厅：
- request = 客人点单
- response = 服务员回应
- 中间件 = 厨房加工流程
- 路由 = 不同窗口（外卖、堂食、咖啡）

WebSocket = 电话通话：
- HTTP = 写信（一问一答）
- WebSocket = 打电话（双向实时）
```

**📝 关键概念：**
- **Keep-Alive**：HTTP连接复用机制
- **请求管道化**：在一个连接上发送多个请求
- **代理服务器**：转发HTTP请求的中间服务器

### 📖 第47天：进程、子进程与集群

**⚚ Node.js进程模型（必背）：**
```javascript
// 进程信息
console.log('PID:', process.pid)           // 进程ID
console.log('Platform:', process.platform) // 操作系统
console.log('Node Version:', process.version) // Node版本
console.log('Memory Usage:', process.memoryUsage()) // 内存使用

// 进程事件
process.on('exit', (code) => {
  console.log('进程退出，退出码:', code)
})

process.on('uncaughtException', (err) => {
  console.error('未捕获的异常:', err)
  process.exit(1)
})
```

**🔄 子进程创建方式（必记）：**
```javascript
const { spawn, exec, execFile, fork } = require('child_process')

// spawn: 启动新进程执行命令
const ls = spawn('ls', ['-la'])
ls.stdout.on('data', (data) => console.log(data.toString()))

// exec: 执行shell命令
exec('ls -la', (error, stdout, stderr) => {
  if (error) throw error
  console.log(stdout)
})

// fork: 创建新的Node.js进程
const child = fork('./worker.js')
child.send({ message: 'hello' })
child.on('message', (msg) => console.log('收到消息:', msg))
```

**🏭 集群模式（必背）：**
```javascript
const cluster = require('cluster')
const numCPUs = require('os').cpus().length

if (cluster.isMaster) {
  // 主进程：创建工作进程
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork()
  }
  
  cluster.on('exit', (worker) => {
    console.log(`工作进程 ${worker.process.pid} 退出`)
    cluster.fork() // 重启工作进程
  })
} else {
  // 工作进程：处理实际请求
  require('./app.js')
}
```

**⚡ 进程间通信（IPC）（必记）：**
```javascript
// 父子进程通信
// parent.js
const child = fork('./child.js')
child.send({ type: 'start', data: 'hello' })
child.on('message', (message) => {
  console.log('父进程收到:', message)
})

// child.js
process.on('message', (message) => {
  console.log('子进程收到:', message)
  process.send({ type: 'response', result: 'processed' })
})
```

**🎯 进程管理最佳实践（必背）：**
```
1. 优雅关闭：
   - 监听SIGTERM信号
   - 关闭服务器停止接收新请求
   - 等待现有请求处理完成
   - 关闭数据库连接
   - 退出进程

2. 错误处理：
   - 捕获未处理异常
   - 记录错误日志
   - 通知监控系统
   - 重启进程

3. 负载均衡：
   - 使用cluster模块创建多进程
   - PM2进程管理器
   - 反向代理（Nginx）
```

**🎭 生活化类比（必背）：**
```
主进程 = 餐厅经理：
- 分配任务给服务员（工作进程）
- 监控服务员状态
- 服务员离职时招聘新人

工作进程 = 服务员：
- 处理具体客人需求
- 向经理汇报工作状态
- 按经理指示执行任务

集群 = 连锁店：
- 多个分店同时营业（多进程）
- 分担客流压力（负载均衡）
- 一家店关闭不影响其他店（故障隔离）
```

**📝 关键概念：**
- **负载均衡**：请求分发到多个工作进程
- **零停机重启**：更新代码时不中断服务
- **进程监控**：监控进程状态和资源使用

### 📖 第48天：Node.js性能优化与生态系统

**⚡ 性能优化策略（必背）：**
```javascript
// 1. 事件循环优化
// 避免阻塞事件循环
setImmediate(() => {
  // 将CPU密集任务分割
  heavyComputation()
})

// 2. 内存优化
// 及时释放大对象引用
let largeData = loadLargeData()
processData(largeData)
largeData = null // 帮助垃圾回收

// 3. Stream使用
// 处理大文件用流，不要一次读入内存
fs.createReadStream('large-file.txt')
  .pipe(transform)
  .pipe(fs.createWriteStream('output.txt'))

// 4. 连接池
// 数据库连接复用
const pool = mysql.createPool({
  connectionLimit: 10,
  host: 'localhost',
  database: 'test'
})
```

**🔧 内存管理与垃圾回收（必记）：**
- **堆内存结构**：
  - 新生代（Young Generation）：短期对象
  - 老生代（Old Generation）：长期对象
  - 大对象空间：超大对象直接分配

- **垃圾回收算法**：
  - Scavenge：新生代垃圾回收（快速）
  - Mark-Sweep：老生代标记清除
  - Mark-Compact：老生代标记整理

**🎯 性能监控工具（必背）：**
```javascript
// 1. 内置性能监控
const { performance, PerformanceObserver } = require('perf_hooks')

const obs = new PerformanceObserver((list) => {
  list.getEntries().forEach((entry) => {
    console.log(`${entry.name}: ${entry.duration}ms`)
  })
})
obs.observe({ entryTypes: ['measure'] })

// 2. 内存使用监控
setInterval(() => {
  const usage = process.memoryUsage()
  console.log('内存使用:', {
    rss: Math.round(usage.rss / 1024 / 1024) + ' MB',      // 总内存
    heapUsed: Math.round(usage.heapUsed / 1024 / 1024) + ' MB', // 堆使用
    external: Math.round(usage.external / 1024 / 1024) + ' MB'  // 外部内存
  })
}, 5000)

// 3. CPU使用监控
const startUsage = process.cpuUsage()
setTimeout(() => {
  const usage = process.cpuUsage(startUsage)
  console.log('CPU使用:', usage)
}, 1000)
```

**🏗️ Node.js生态系统核心（必记）：**
- **包管理器**：
  - npm：官方包管理器
  - yarn：Facebook开发，更快更安全
  - pnpm：节省磁盘空间，符号链接共享

- **构建工具**：
  - Webpack：模块打包器
  - Rollup：ES6模块打包
  - Vite：快速构建工具
  - esbuild：超快JavaScript打包器

- **测试框架**：
  - Jest：功能全面的测试框架
  - Mocha：灵活的测试框架
  - Vitest：基于Vite的快速测试

**🎯 生产环境部署（必背）：**
```
1. 进程管理：
   - PM2：生产级进程管理器
   - Docker：容器化部署
   - Kubernetes：容器编排

2. 负载均衡：
   - Nginx：反向代理和负载均衡
   - HAProxy：高可用负载均衡器
   - AWS ELB：云端负载均衡

3. 监控告警：
   - APM工具：New Relic、DataDog
   - 日志收集：ELK Stack、Fluentd
   - 错误追踪：Sentry、Bugsnag

4. 安全防护：
   - HTTPS证书配置
   - 安全头设置
   - 依赖漏洞扫描
   - 访问频率限制
```

**🎭 生活化类比（必背）：**
```
Node.js生态 = 城市基础设施：
- npm = 商店（获取工具和材料）
- 框架 = 建筑模板（快速建房）
- 工具链 = 施工设备（提高效率）
- 监控 = 安防系统（保障安全）

性能优化 = 交通优化：
- 事件循环 = 主干道（保持畅通）
- 内存管理 = 垃圾清理（及时回收）
- 缓存 = 就近服务（减少路程）
- 集群 = 多车道（分流压力）
```

**📝 关键概念：**
- **事件循环延迟**：监控事件循环是否被阻塞
- **背压处理**：流处理中的压力缓解机制
- **热重载**：开发时代码变更自动重启

**🧠 第5周Node.js知识总结（选学，可跳过）：**
1. **运行时特性**：V8引擎+libuv，单线程事件驱动，非阻塞I/O
2. **事件循环**：六个阶段，微任务优先级，process.nextTick最高
3. **模块系统**：CommonJS运行时加载，ES6编译时加载，模块缓存机制
4. **文件流操作**：同步异步Promise三种方式，Stream分块处理大文件
5. **网络编程**：HTTP模块创建服务器，WebSocket双向通信，HTTPS加密
6. **进程集群**：cluster多进程，IPC进程通信，负载均衡提升性能
7. **性能优化**：内存垃圾回收，事件循环监控，生产环境部署策略

---

**📝 最终背诵口诀（终极版）：**
```
模块实体仓储服务，控制装饰依赖注入
网络协议TCP UDP，HTTP RPC通信明了
架构演进单体微服务，分布式CAP一致性
并发线程协程锁，消息队列事件驱动
缓存分层存储选型，系统设计可观测性
异常处理日志监控，性能优化负载均衡
Node基础事件循环，模块文件流网络
进程集群性能优化，生态工具部署运维
测试文档权限安全，规范清单套路熟练
后端思维已建立，企业开发得心应手
```
